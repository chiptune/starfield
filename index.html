<!DOCTYPE html>
<html lang="en-US">
  <head>
    <title>starfield</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="robots" content="follow index archive" />
    <meta name="author" content="REZ ᕕ( ᐛ )ᕗ" />
    <meta name="description" content="interactive code tutorial" />
    <link rel="preload" href="starfield.css" as="style" type="text/css" />
    <link
      rel="preload"
      href="fonts/microgramma.woff2"
      as="font"
      type="font/woff2"
      crossorigin="anonymous"
    />
    <link
      rel="preload"
      href="fonts/chakra_petch.ttf"
      as="font"
      type="font/ttf"
      crossorigin="anonymous"
    />
    <link
      rel="preload"
      href="fonts/hud.woff2"
      as="font"
      type="font/woff2"
      crossorigin="anonymous"
    />
    <link rel="stylesheet" href="starfield.css" />
    <script type="application/javascript" src="starfield.js"></script>
  </head>

  <body onload="init()">
    <div id="root">
      <div id="header">
        <img id="logo" />
        <div id="title">
          starfield<img id="cute_star" /><br />
          <div id="subtitle">an interactive tutorial</div>
        </div>
        <div id="credits">
          christophe resigne<br />
          <a href="https://github.com/chiptune/starfield">github</a><br />
          <div id="version"></div>
        </div>
      </div>
      <div id="content">
        <div id="visual">
          <canvas id="starfield"></canvas>
          <div id="variables"></div>
        </div>
        <div id="menu">
          <div id="steps"></div>
          <div id="config">
            <form>
              <label for="motion">motion</label>
              <input type="checkbox" id="motion" />
            </form>
            <form>
              <label for="overlay">overlay</label>
              <input type="checkbox" id="overlay" />
            </form>
            <form>
              <label for="debug">debug</label>
              <input type="checkbox" id="debug" />
            </form>
          </div>
        </div>
        <code><div></div></code>
      </div>
    </div>
  </body>
</html>

<script type="application/javascript" id="step0">
  step0_draw = () => {
    translate(); // REM
    ctx.fillStyle = "#000";
    ctx.fillRect(-x, -y, w, h); // REM
    //ctx.fillRect(-w / 2, -h / 2, w, h); // NREM
    //ctx.textAlign = 'center'; // REM
    //ctx.fillStyle = '#fff'; // REM
    //ctx.font = 'normal 20px/100% sans-serif'; // REM
    //ctx.fillText('ᕕ( ᐛ )ᕗ', 0, -16); // REM
    /* display a cute star here */
    x = px + (drago ? -px : 0) - _w / 4; // REM
    y = py + (drago ? -py : 0) - _w / 4; // REM
    ctx.drawImage(cute_star, 0, 0, 128 * dpr, 128 * dpr, x, y, _w / 2, _w / 2); // REM
    overlay_draw(); // REM
    debug_draw(); // REM
    delta = time; // REM
    time = performance.now(); // REM
    tick(step0_draw); // REM
  };

  // # README #
  // you can use the mouse to move the stars (click + drag)
  // and the mousewheel to change the distance.
  // shift + drag will change the world origin.

  // # SHORTCUTS #
  // r: reset all parameters
  // c: reset stars origin
  // p/space: animation play/pause
  // o: overlay on/off
  // d/esc: debug mode on/off
  // up/down: cycle through steps

  // # SOURCE #
  // github.com/chiptune/starfield
</script>

<script type="application/javascript" id="step1">
  step1_init = () => {
    window.seed = (1 + Math.sqrt(5)) / 2; // REM
    for (let i = 0; i < _nb; i++) {
      stars[i] = new Float32Array(2);
      stars[i][0] = vx + (lcg() - 0.5) * _w;
      stars[i][1] = vy + (lcg() - 0.5) * _w;
    }
  };

  step1_draw = () => {
    translate(); // REM
    ctx.fillStyle = "#000";
    ctx.fillRect(-x, -y, w, h); // REM
    //ctx.fillRect(-w / 2, -h / 2, w, h); // NREM
    ctx.fillStyle = "#fff";
    for (let i = 0; i < _nb; i++) {
      [x, y] = stars[i];
      ctx.beginPath();
      x += drago ? -px : 0; // REM
      y += drago ? -py : 0; // REM
      ctx.arc(px + x, py + y, _s * 2, 0, CIRCLE); // REM
      //ctx.arc(x, y, _s * 2, 0, CIRCLE); // NREM
      ctx.fill();
    }
    overlay_draw(); // REM
    debug_draw(); // REM
    delta = time; // REM
    time = performance.now(); // REM
    tick(step1_draw); // REM
  };

  CIRCLE = Math.PI * 2; // 360° in radians
</script>

<script type="application/javascript" id="step2">
  step2_init = () => {
    window.seed = (1 + Math.sqrt(5)) / 2; // REM
    depth = _fp - _np;
    for (let i = 0; i < _nb; i++) {
      stars[i] = new Float32Array(3);
      stars[i][0] = vx + (lcg() - 0.5) * _w;
      stars[i][1] = vy + (lcg() - 0.5) * _w;
      stars[i][2] = _np + (depth / _nb) * i;
    }
  };

  step2_draw = () => {
    translate(); // REM
    ctx.fillStyle = "#000";
    ctx.fillRect(-x, -y, w, h); // REM
    //ctx.fillRect(-w / 2, -h / 2, w, h); // NREM
    ctx.fillStyle = "#fff";
    for (let i = 0; i < _nb; i++) {
      [x, y, z] = stars[i];
      [x, y, z] = get_p(x, y, z); // REM
      ctx.beginPath();
      ctx.arc(x / z, y / z, _s * 2, 0, CIRCLE);
      ctx.fill();
    }
    overlay_draw(); // REM
    debug_draw(); // REM
    delta = time; // REM
    time = performance.now(); // REM
    tick(step2_draw); // REM
  };
</script>

<script type="application/javascript" id="step3">
  step3_draw = () => {
    translate(); // REM
    ctx.fillStyle = "#000";
    ctx.fillRect(-x, -y, w, h); // REM
    //ctx.fillRect(-w / 2, -h / 2, w, h); // NREM
    ctx.fillStyle = "#fff";
    for (let i = 0; i < _nb; i++) {
      [x, y, z] = stars[i];
      [x, y, z] = get_p(x, y, z); // REM
      r = (1 / z) * _f;
      ctx.beginPath();
      ctx.arc(x * r, y * r, _s * r, 0, CIRCLE);
      ctx.fill();
    }
    overlay_draw(); // REM
    debug_draw(); // REM
    delta = time; // REM
    time = performance.now(); // REM
    tick(step3_draw); // REM
  };
</script>

<script type="application/javascript" id="step4">
  step4_draw = () => {
    translate(); // REM
    ctx.fillStyle = "#000";
    ctx.fillRect(-x, -y, w, h); // REM
    //ctx.fillRect(-w / 2, -h / 2, w, h); // NREM
    for (let i = 0; i < _nb; i++) {
      [x, y, z] = stars[i];
      [x, y, z] = get_p(x, y, z); // REM
      r = _f / z;
      z -= _np;
      c = (1 - Math.pow(z / depth, _cl)) * 255.999;
      ctx.fillStyle = `rgb(${c},${c},${c})`;
      ctx.beginPath();
      ctx.arc(x * r, y * r, _s * r, 0, CIRCLE);
      ctx.fill();
    }
    overlay_draw(); // REM
    debug_draw(); // REM
    delta = time; // REM
    time = performance.now(); // REM
    tick(step4_draw); // REM
  };
</script>

<script type="application/javascript" id="step5">
  step5_draw = () => {
    translate(); // REM
    ctx.fillStyle = "#000";
    ctx.fillRect(-x, -y, w, h); // REM
    //ctx.fillRect(-w / 2, -h / 2, w, h); // NREM
    for (let i = 0; i < _nb; i++) {
      [x, y, z] = stars[get_index(i)];
      [x, y, z] = get_p(x, y, z); // REM
      r = _f / z;
      z -= _np;
      c = (1 - Math.pow(z / depth, _cl)) * 255.999;
      ctx.fillStyle = `rgb(${c},${c},${c})`;
      ctx.beginPath();
      ctx.arc(x * r, y * r, _s * r, 0, CIRCLE);
      ctx.fill();
    }
    overlay_draw(); // REM
    debug_draw(); // REM
    delta = time; // REM
    time = performance.now(); // REM
    tick(step5_draw); // REM
  };

  get_index = (i) => {
    let d = distance % depth;
    if (d < 0) {
      d += depth;
    }
    let n = Math.floor((d / depth) * _nb) - i;
    if (n < 0) {
      n += _nb;
    }
    if (n > _nb - 1) {
      n -= _nb;
    }
    return n;
  };
</script>

<script type="application/javascript" id="step6">
  step6_draw = () => {
    translate(); // REM
    ctx.fillStyle = `rgba(0,0,0,${_o})`;
    ctx.fillRect(-x, -y, w, h); // REM
    //ctx.fillRect(-w / 2, -h / 2, w, h); // NREM
    for (let i = 0; i < _nb; i++) {
      [x, y, z] = get_position(stars[get_index(i)]);
      r = _f / z;
      z -= _np;
      c = (1 - Math.pow(z / depth, _cl)) * 255.999;
      ctx.fillStyle = `rgb(${c},${c},${c})`;
      ctx.beginPath();
      ctx.arc(x * r, y * r, _s * r, 0, CIRCLE);
      ctx.fill();
    }
    overlay_draw(); // REM
    debug_draw(); // REM
    delta = time;
    time = performance.now();
    update_distance(); // REM
    //distance += (time - delta) / 1000 * _m; // NREM
    tick(step6_draw);
  };

  get_position = (star) => {
    [x, y, z] = star;
    if (drag) x += px; // REM
    if (drag) y += py; // REM
    z -= distance % depth;
    if (z < _np) {
      z += depth;
    } else if (z > _fp) {
      z -= depth;
    }
    return [x, y, z];
  };
</script>

<script type="application/javascript" id="step7">
  step7_draw = () => {
    translate(); // REM
    ctx.fillStyle = `rgba(0,0,0,${_o})`;
    ctx.fillRect(-x, -y, w, h); // REM
    //ctx.fillRect(-w / 2, -h / 2, w, h); // NREM
    for (let i = 0; i < _nb; i++) {
      [x, y, z] = get_position(stars[i]);
      r = _f / z;
      d = _g * r;
      x *= r;
      y *= r;
      z -= _np;
      a = 1 - Math.pow(z / depth, _cl);
      rad1 = (_s / _g) * 0.95;
      rad2 = (_s / _g) * 1.05;
      g = ctx.createRadialGradient(x, y, 0, x, y, d);
      g.addColorStop(0, `hsl(0 0% 100% / ${a})`);
      g.addColorStop(rad1, `hsl(0 0% 100% / ${a})`);
      g.addColorStop(rad2, `hsl(0 0% 100% / ${a * _h * _o})`);
      g.addColorStop(1, "hsl(0 0% 100% / 0)");
      ctx.fillStyle = g;
      ctx.fillRect(x - d, y - d, d * 2, d * 2);
    }
    overlay_draw(); // REM
    debug_draw(); // REM
    delta = time;
    time = performance.now();
    update_distance(); // REM
    //distance += (time - delta) / 1000 * _m; // NREM
    tick(step7_draw);
  };
</script>

<script type="application/javascript" id="step8">
  step8_draw = () => {
    translate(); // REM
    ctx.fillStyle = `rgba(0,0,0,${_o})`;
    ctx.fillRect(-x, -y, w, h); // REM
    //ctx.fillRect(-w / 2, -h / 2, w, h); // NREM
    for (let i = 0; i < _nb; i++) {
      [x, y, z] = get_position(stars[i]);
      r = _f / z;
      d = _g * r;
      x *= r;
      y *= r;
      z -= _np;
      dof = Math.min(1, z / (depth * _dof));
      a = (1 - Math.pow(z / depth, _cl)) * dof;
      rad1 = Math.max((_s / _g) * 0.95 * dof, 0);
      rad2 = Math.min((_s / _g) * 1.05 * (2 - dof), 1);
      g = ctx.createRadialGradient(x, y, 0, x, y, d);
      g.addColorStop(0, `hsl(0 0% 100% / ${a})`);
      g.addColorStop(rad1, `hsl(0 0% 100% / ${a})`);
      g.addColorStop(rad2, `hsl(0 0% 100% / ${a * _h * _o})`);
      g.addColorStop(1, "hsl(0 0% 100% / 0)");
      ctx.fillStyle = g;
      ctx.fillRect(x - d, y - d, d * 2, d * 2);
    }
    overlay_draw(); // REM
    debug_draw(); // REM
    delta = time;
    time = performance.now();
    update_distance(); // REM
    //distance += (time - delta) / 1000 * _m; // NREM
    tick(step8_draw);
  };
</script>

<script type="application/javascript" id="step9">
  step9_draw = () => {
    step9_clear();
    for (let i = 0; i < _nb; i++) {
      [x, y, z] = get_position(stars[i]);
      r = _f / z;
      d = _g * r;
      x *= r;
      y *= r;
      z -= _np;
      dof = Math.min(1, z / (depth * _dof));
      l = (1 - Math.pow(z / depth, _cl)) * 100 * dof;
      rad1 = Math.max((_s / _g) * 0.95 * dof, 0);
      rad2 = Math.min((_s / _g) * 1.05 * (2 - dof), 1);
      g = ctx.createRadialGradient(x, y, 0, x, y, d);
      g.addColorStop(0, `hsl(0 0% ${l}%)`);
      g.addColorStop(rad1, `hsl(0 0% ${l}%)`);
      g.addColorStop(rad2, `hsl(0 0% ${l * _h * _o}%)`);
      g.addColorStop(1, "hsl(0 0% 0%)");
      ctx.fillStyle = g;
      ctx.fillRect(x - d, y - d, d * 2, d * 2);
    }
    overlay_draw(); // REM
    debug_draw(); // REM
    delta = time;
    time = performance.now();
    update_distance(); // REM
    //distance += (time - delta) / 1000 * _m; // NREM
    tick(step9_draw);
  };

  step9_clear = () => {
    ctx.setTransform(1, 0, 0, 1, 0, 0); // REM
    ctx.scale(dpr, dpr); // REM
    x = ox + (drago ? px : 0); // REM
    y = oy + (drago ? py : 0); // REM
    ctx.translate(x, y); // REM
    ctx.globalCompositeOperation = "source-over";
    ctx.fillStyle = `rgba(0,0,0,${_o})`;
    ctx.fillRect(-x, -y, w, h); // REM
    //ctx.fillRect(-w / 2, -h / 2, w, h); // NREM
    ctx.globalCompositeOperation = "lighter";
  };
</script>

<script type="application/javascript" id="step10">
  step10_init = () => {
    window.seed = (1 + Math.sqrt(5)) / 2; // REM
    depth = _fp - _np;
    for (let i = 0; i < _nb; i++) {
      x = lcg() - 0.5;
      y = lcg() - 0.5;
      stars[i] = new Float32Array(5);
      stars[i][0] = vx + x * _w;
      stars[i][1] = vy + y * _w;
      stars[i][2] = _np + (depth / _nb) * i;
      stars[i][3] = (lcg() * 3 - x - y) * 30;
      stars[i][4] = lcg() * 200 - 50;
    }
  };

  step10_draw = () => {
    clear();
    for (let i = 0; i < _nb; i++) {
      [x, y, z] = get_position(stars[i]);
      r = _f / z;
      d = _g * r;
      x *= r;
      y *= r;
      z -= _np;
      u = stars[i][3] + (180 / depth) * (z + distance);
      s = stars[i][4] * _cs;
      dof = Math.min(1, z / (depth * _dof));
      l = (1 - Math.pow(z / depth, _cl)) * 100 * dof * _o;
      rad1 = Math.max((_s / _g) * dof * 0.95, 0);
      rad2 = Math.min((_s / _g) * (2.05 - dof), 1);
      g = ctx.createRadialGradient(x, y, 0, x, y, d);
      g.addColorStop(0, `hsl(${u} ${s}% ${l / _o}%)`);
      g.addColorStop(rad1, `hsl(${u} ${s}% ${l}%)`);
      g.addColorStop(rad2, `hsl(${u} ${s}% ${l * _h}%)`);
      g.addColorStop(1, `hsl(${u} 0% 0%)`);
      ctx.fillStyle = g;
      ctx.fillRect(x - d, y - d, d * 2, d * 2);
    }
    overlay_draw(); // REM
    debug_draw(); // REM
    delta = time;
    time = performance.now();
    update_distance(); // REM
    //distance += (time - delta) / 1000 * _m; // NREM
    tick(step10_draw);
  };

  clear = () => {
    ctx.setTransform(1, 0, 0, 1, 0, 0); // REM
    ctx.scale(dpr, dpr); // REM
    x = ox + (drago ? px : 0); // REM
    y = oy + (drago ? py : 0); // REM
    ctx.translate(x, y); // REM
    ctx.globalCompositeOperation = "source-over";
    ctx.fillStyle = `hsl(${(360 / depth) * distance} ${
      _cs * 100
    }%  5% / ${_o})`;
    ctx.fillRect(-x, -y, w, h);
    ctx.globalCompositeOperation = "lighter";
  };
</script>

<script type="application/javascript" id="step11">
  step11_draw = () => {
    clear();
    for (let i = 0; i < _nb; i++) {
      [x, y, z] = get_position(stars[i]);
      r = _f / z;
      d = _g * r;
      x *= r;
      y *= r;
      z -= _np;
      u = stars[i][3] + (180 / depth) * (z + distance);
      s = stars[i][4] * _cs;
      dof = Math.min(1, z / (depth * _dof));
      l = (1 - Math.pow(z / depth, _cl)) * 100 * dof * _o;
      rad1 = Math.max((_s / _g) * dof * 0.95, 0);
      rad2 = Math.min((_s / _g) * (2.05 - dof), 1);
      g = ctx.createRadialGradient(x, y, 0, x, y, d);
      g.addColorStop(0, `hsl(${u} ${s}% ${l / _o}%)`);
      g.addColorStop(rad1, `hsl(${u} ${s}% ${l}%)`);
      g.addColorStop(rad2, `hsl(${u} ${s}% ${l * _h}%)`);
      g.addColorStop(1, `hsl(${u} 0% 0%)`);
      ctx.fillStyle = g;
      ctx.fillRect(x - d, y - d, d * 2, d * 2);
      k = _k * r;
      if (s > 0) continue;
      rad1 = Math.max((_s / _k) * dof * 0.95, 0);
      rad2 = Math.min((_s / _k) * (2.05 - dof), 1);
      g = ctx.createRadialGradient(x, y, 0, x, y, k);
      g.addColorStop(0, "#000");
      g.addColorStop(rad1, `hsl(${u} ${s}% ${l}%)`);
      g.addColorStop(rad2, `hsl(${u} ${s}% ${l}%)`);
      g.addColorStop(0.3, `hsl(${u + 30} ${s}% ${l / 3}%)`);
      g.addColorStop(1, `hsl(${u + 90} ${s}% 0%)`);
      ctx.fillStyle = g;
      sw = _s * r * 1.8;
      st = sw / 6;
      sr = sw - st;
      ctx.beginPath();
      ctx.arc(x - sw, y - sw, sr, CIRCLE / 4, 0, true);
      ctx.lineTo(x - st, y - k);
      ctx.lineTo(x + st, y - k);
      ctx.arc(x + sw, y - sw, sr, CIRCLE / 2, CIRCLE / 4, true);
      ctx.lineTo(x + k, y - st);
      ctx.lineTo(x + k, y + st);
      ctx.arc(x + sw, y + sw, sr, -CIRCLE / 4, CIRCLE / 2, true);
      ctx.lineTo(x + st, y + k);
      ctx.lineTo(x - st, y + k);
      ctx.arc(x - sw, y + sw, sr, 0, -CIRCLE / 4, true);
      ctx.lineTo(x - k, y + st);
      ctx.lineTo(x - k, y - st);
      ctx.fill();
    }
    overlay_draw(); // REM
    debug_draw(); // REM
    delta = time;
    time = performance.now();
    update_distance(); // REM
    //distance += (time - delta) / 1000 * _m; // NREM
    tick(step11_draw);
  };
</script>

<script type="application/javascript" id="step12">
  step12_init = () => {
    window.seed = (1 + Math.sqrt(5)) / 2; // REM
    depth = _fp - _np;
    for (let i = 0; i < _nb; i++) {
      x = lcg() - 0.5;
      y = lcg() - 0.5;
      stars[i] = new Float32Array(5);
      stars[i][0] = vx + x * _w;
      stars[i][1] = vy + y * _w;
      stars[i][2] = _np + (depth / _nb) * i;
      stars[i][3] = (lcg() * 3 - x - y) * 30;
      stars[i][4] = lcg() * 200 - 50;
    }
    let k = _nb;
    for (let i = 0; i < _t1; i++) {
      for (let j = 0; j < _t2; j++) {
        a = (CIRCLE / _t2) * j;
        a += (CIRCLE / _t1) * i;
        r = _w / 8;
        stars[k] = new Float32Array(5);
        stars[k][0] = vx + r * Math.cos(a);
        stars[k][1] = vy + r * Math.sin(a);
        stars[k][2] = _np + (depth / _t1) * i;
        stars[k][3] = (360 / _t2) * j;
        stars[k][4] = 50;
        k++;
      }
    }
  };

  step12_draw = () => {
    clear();
    for (let i = 0; i < _nb + _t1 * _t2; i++) {
      [x, y, z] = get_position(stars[i]);
      r = _f / z;
      d = _g * r;
      x *= r;
      y *= r;
      z -= _np;
      u = stars[i][3] + (180 / depth) * (z + distance);
      s = stars[i][4] * _cs;
      dof = Math.min(1, z / (depth * _dof));
      l = (1 - Math.pow(z / depth, _cl)) * 100 * dof * _o;
      rad1 = Math.max((_s / _g) * dof * 0.95, 0);
      rad2 = Math.min((_s / _g) * (2.05 - dof), 1);
      g = ctx.createRadialGradient(x, y, 0, x, y, d);
      g.addColorStop(0, `hsl(${u} ${s}% ${l / _o}%)`);
      g.addColorStop(rad1, `hsl(${u} ${s}% ${l}%)`);
      g.addColorStop(rad2, `hsl(${u} ${s}% ${l * _h}%)`);
      g.addColorStop(1, `hsl(${u} 0% 0%)`);
      ctx.fillStyle = g;
      ctx.fillRect(x - d, y - d, d * 2, d * 2);
    }
    overlay_draw(); // REM
    debug_draw(); // REM
    delta = time;
    time = performance.now();
    update_distance(); // REM
    //distance += (time - delta) / 1000 * _m; // NREM
    tick(step12_draw);
  };
</script>
